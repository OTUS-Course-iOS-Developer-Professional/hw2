//
// EvolutionChainChainEvolutionDetailsInner.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct EvolutionChainChainEvolutionDetailsInner: Codable, JSONEncodable, Hashable {

    public enum TimeOfDay: String, Codable, CaseIterable {
        case day = "day"
        case night = "night"
    }
    public var item: EvolutionChainChainEvolutionDetailsInnerItem?
    public var trigger: EvolutionTrigger?
    /** The required female gender of the evolving Pokémon species. Must be either 1 or 2, or null if the Pokémon species has no gender or the gender is fixed. */
    public var gender: Int?
    public var heldItem: EvolutionChainChainEvolutionDetailsInnerItem?
    public var knownMove: EvolutionChainChainEvolutionDetailsInnerKnownMove?
    public var knownMoveType: EvolutionChainChainEvolutionDetailsInnerKnownMoveType?
    public var location: EvolutionChainChainEvolutionDetailsInnerLocation?
    /** The minimum required level of the evolving Pokémon species */
    public var minLevel: Int?
    /** The minimum required happiness of the evolving Pokémon species */
    public var minHappiness: Int?
    /** The minimum required beauty of the evolving Pokémon species */
    public var minBeauty: Int?
    /** The minimum required affection of the evolving Pokémon species */
    public var minAffection: Int?
    /** Whether or not it must be raining in the overworld to evolve into this Pokémon species */
    public var needsOverworldRain: Bool?
    public var partySpecies: EvolutionChainChainEvolutionDetailsInnerPartySpecies?
    public var partyType: EvolutionChainChainEvolutionDetailsInnerKnownMoveType?
    /** The required relation between the Pokémon's Attack and Defense stats. 1 means Attack > Defense, 0 means Attack = Defense, and -1 means Attack < Defense. */
    public var relativePhysicalStats: Int?
    /** The required time of day. Day or night. */
    public var timeOfDay: TimeOfDay?
    public var tradeSpecies: EvolutionChainChainEvolutionDetailsInnerPartySpecies?
    /** Whether or not the 3DS needs to be turned upside-down as this Pokémon levels up. */
    public var turnUpsideDown: Bool?

    public init(item: EvolutionChainChainEvolutionDetailsInnerItem? = nil, trigger: EvolutionTrigger? = nil, gender: Int? = nil, heldItem: EvolutionChainChainEvolutionDetailsInnerItem? = nil, knownMove: EvolutionChainChainEvolutionDetailsInnerKnownMove? = nil, knownMoveType: EvolutionChainChainEvolutionDetailsInnerKnownMoveType? = nil, location: EvolutionChainChainEvolutionDetailsInnerLocation? = nil, minLevel: Int? = nil, minHappiness: Int? = nil, minBeauty: Int? = nil, minAffection: Int? = nil, needsOverworldRain: Bool? = nil, partySpecies: EvolutionChainChainEvolutionDetailsInnerPartySpecies? = nil, partyType: EvolutionChainChainEvolutionDetailsInnerKnownMoveType? = nil, relativePhysicalStats: Int? = nil, timeOfDay: TimeOfDay? = nil, tradeSpecies: EvolutionChainChainEvolutionDetailsInnerPartySpecies? = nil, turnUpsideDown: Bool? = nil) {
        self.item = item
        self.trigger = trigger
        self.gender = gender
        self.heldItem = heldItem
        self.knownMove = knownMove
        self.knownMoveType = knownMoveType
        self.location = location
        self.minLevel = minLevel
        self.minHappiness = minHappiness
        self.minBeauty = minBeauty
        self.minAffection = minAffection
        self.needsOverworldRain = needsOverworldRain
        self.partySpecies = partySpecies
        self.partyType = partyType
        self.relativePhysicalStats = relativePhysicalStats
        self.timeOfDay = timeOfDay
        self.tradeSpecies = tradeSpecies
        self.turnUpsideDown = turnUpsideDown
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case item
        case trigger
        case gender
        case heldItem = "held_item"
        case knownMove = "known_move"
        case knownMoveType = "known_move_type"
        case location
        case minLevel = "min_level"
        case minHappiness = "min_happiness"
        case minBeauty = "min_beauty"
        case minAffection = "min_affection"
        case needsOverworldRain = "needs_overworld_rain"
        case partySpecies = "party_species"
        case partyType = "party_type"
        case relativePhysicalStats = "relative_physical_stats"
        case timeOfDay = "time_of_day"
        case tradeSpecies = "trade_species"
        case turnUpsideDown = "turn_upside_down"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(item, forKey: .item)
        try container.encodeIfPresent(trigger, forKey: .trigger)
        try container.encodeIfPresent(gender, forKey: .gender)
        try container.encodeIfPresent(heldItem, forKey: .heldItem)
        try container.encodeIfPresent(knownMove, forKey: .knownMove)
        try container.encodeIfPresent(knownMoveType, forKey: .knownMoveType)
        try container.encodeIfPresent(location, forKey: .location)
        try container.encodeIfPresent(minLevel, forKey: .minLevel)
        try container.encodeIfPresent(minHappiness, forKey: .minHappiness)
        try container.encodeIfPresent(minBeauty, forKey: .minBeauty)
        try container.encodeIfPresent(minAffection, forKey: .minAffection)
        try container.encodeIfPresent(needsOverworldRain, forKey: .needsOverworldRain)
        try container.encodeIfPresent(partySpecies, forKey: .partySpecies)
        try container.encodeIfPresent(partyType, forKey: .partyType)
        try container.encodeIfPresent(relativePhysicalStats, forKey: .relativePhysicalStats)
        try container.encodeIfPresent(timeOfDay, forKey: .timeOfDay)
        try container.encodeIfPresent(tradeSpecies, forKey: .tradeSpecies)
        try container.encodeIfPresent(turnUpsideDown, forKey: .turnUpsideDown)
    }
}

